# Standard pipeline to release go apps for Azure-AWS
# [Gitversion examples](https://github.com/GitTools/actions/tree/main/docs/examples/azure/gitversion)
# TODO: Modify pipeline to auto increment patch version using gitVersion & Keep release branching strategy. Write proper docs for the pipeline.
parameters:
- name: clean
  displayName: Checkout clean
  type: boolean
  default: false
  values:
  - false
  - true

trigger:
  batch: true
  branches:
    include:
    - main
    - release/*
  paths:                    # docs are only for repository and can be ignored for this pipeline
    exclude:
      - readme.md

pool: K8S-AZURE-AWS

variables:
#  - name: IsRelease
#    value: $[contains(variables['Build.SourceBranch'], '/release/')] # builds on get triggered when on release branch
  - name: GoVersion
    value: '1.23.3'
  - name: GoReleaserVersion
    value: 'v2.4.7'
  - name: GoBin
    value: '$(System.DefaultWorkingDirectory)/gobin'
  - name: ProjectName
    value: 'chartfetch'
  - name: TagName
    value: 'v$(Build.SourceBranchName)'
  - name: ProviderVersion
    value: $(Build.SourceBranchName)
  - name: engieAssetPriority
    value: P4
  - name: engieAssetClassification
    value: internal



resources:
  repositories:
    - repository: pipelineTemplates
      type: git
      name: pipelineTemplates

stages:
  - stage: Pre_Release
    displayName: "Tag branch"
#    condition: eq(variables['IsRelease'], 'True')
    jobs:
    - template: gitversion/gvtag.yml@pipelineTemplates

  - stage: Binary_Build_and_Publish
    displayName: "Build Binary"
    dependsOn: Pre_Release
    jobs:
      - job: Build_provider
        displayName: "Build Binary"
        steps:
        - checkout: self
          clean: ${{ parameters.clean }}
          fetchTags: true
          persistCredentials: true
          fetchDepth: 0
        - task: GoTool@0
          displayName: 'Install GO v$(GoVersion)'
          inputs:
            version: '$(GoVersion)'
            goBin: '$(GoBin)'
        - task: Cache@2
          displayName: 'Cache/Restore goreleaser $(GoReleaserVersion)'
          inputs:
            key: '"$(ProjectName)" | "$(Agent.OS) | "$(GoReleaserVersion)"'
            path: '$(GoBin)'
            cacheHitVar: 'CACHE_RESTORED'
        - task: JFrogGo@1
          displayName: 'Install goreleaser $(GoReleaserVersion)'
          inputs:
            command: 'custom'
            customCommand: 'install'
            goArguments: 'github.com/goreleaser/goreleaser/v2@$(GoReleaserVersion)'
            artifactoryConnection: 'JFrog'
            resolutionRepo: 'prd-go-virtual'
          condition: ne(variables.CACHE_RESTORED, 'true')
        - task: Bash@3
          displayName: 'Prepend GOBIN to PATH'
          inputs:
            targetType: 'inline'
            script: |
              echo '##vso[task.prependpath]$(GOBIN)'
            workingDirectory: '$(System.DefaultWorkingDirectory)'
        - task: DownloadSecureFile@1
          name: pgpprivatekey
          displayName: 'Download PGP private key'
          inputs:
            secureFile: 'PGP PRIVATE KEY BLOCK.txt'
        - task: Bash@3
          displayName: 'Import PGP key'
          inputs:
            targetType: 'inline'
            script: |
              gpg --import '$(pgpprivatekey.secureFilePath)'
        - task: JfrogCliV2@1
          displayName: Configure Artifactory for Go modules
          inputs:
            jfrogPlatformConnection: 'JFrog Platform'
            command: jf go-config --server-id-resolve="1ba894ff-0587-466f-afaa-721bbc527d28" --repo-resolve="prd-go-virtual"
        - task: Bash@3
          displayName: 'Build Go app'
          inputs:
            targetType: 'inline'
            script: |
              echo "Building with version: $(Build.BuildNumber)"
              goreleaser build --clean
            workingDirectory: '$(System.DefaultWorkingDirectory)'
        - task: CopyFiles@2
          inputs:
            SourceFolder: 'dist'
            Contents: '**'
            TargetFolder: '$(Build.ArtifactStagingDirectory)'
            CleanTargetFolder: true
            OverWrite: true
            retryCount: '5'
        - task: JfrogCliV2@1
          displayName: Upload Artifacts to Artifactory
          inputs:
            jfrogPlatformConnection: 'JFrog Platform'
            command: jf rt u "$(Build.ArtifactStagingDirectory)/*" "prd-go-local/$(ProjectName)/$(Build.BuildNumber)/" --flat=true
        - task: JfrogCliV2@1
          displayName: Collect Build Info
          inputs:
            jfrogPlatformConnection: 'JFrog Platform'
            command: jf rt bp "$(Build.DefinitionName)" "$(Build.BuildNumber)"
        - task: JFrogPublishBuildInfo@1
          displayName: Publish Build Info to Artifactory
          inputs:
            artifactoryConnection: 'JFrog'
            buildName: '$(Build.DefinitionName)'                  # this translates to "chartfetch" in our case
            buildNumber: '$(Build.BuildNumber)'                   # this one is set to the same version as GitVersion saved in global variable VERSION, this is being handled automatically since version 6
            projectKey: 'prd'


  - stage: Container_Build_and_Publish
    displayName: "Build and Publish Docker Image"
    dependsOn: Binary_Build_and_Publish
    condition: eq(variables['Build.SourceBranchName'], 'main') # only on commit into main.
    jobs:
      - job: Build_Container
        displayName: "Build and Push Docker Image"
        steps:
          - task: JfrogCliV2@1
            displayName: Download Artifact from Artifactory
            inputs:
              jfrogPlatformConnection: 'JFrog Platform'
              command: jf rt dl "prd-go-local/$(ProjectName)/$(Build.BuildNumber)/$(ProjectName)" "$(System.DefaultWorkingDirectory)/$(ProjectName)" --flat
          - task: Bash@3
            displayName: "debug"
            inputs:
              targetType: inline
              script: |
                ls -al $(System.DefaultWorkingDirectory)/$(ProjectName)
          - task: Docker@2
            displayName: Docker login
            inputs:
              command: login
              containerRegistry: bd989720-133a-4625-969f-b343870eb376
          - bash: |
              docker buildx inspect "${BUILDX_BUILDER}"
              if [[ "$?" != "0" ]]; then
                echo "Creating remote container configuration for buildx"
                docker buildx create --name "${BUILDX_BUILDER}" --driver remote tcp://buildkitd.alm.svc:1234
              fi
            displayName: Setup buildx
          - task: Bash@3
            displayName: Tag Docker Image using $(Build.BuildNumber)
            inputs:
              targetType: inline
              script: |
                imageTag=$(echo "$(Build.BuildNumber)" | tr "[:upper:]" "[:lower:]")
                echo "##vso[task.setvariable variable=imageTag]$imageTag"
          - task: Docker@2
            displayName: Build
            inputs:
              command: build
              repository: "prd-docker-virtual/$(ProjectName)"
              tags: $(imageTag)
              dockerfile: '$(System.DefaultWorkingDirectory)/Dockerfile'
              buildContext: '$(System.DefaultWorkingDirectory)'
              arguments: |
                --build-arg IMAGE_NAME=$(ProjectName)
                --push
            env:
              BUILDX_NO_DEFAULT_ATTESTATIONS: 1
          - task: JFrogPublishBuildInfo@1
            inputs:
              artifactoryConnection: 'JFrog'
              buildName: '$(Build.DefinitionName)'
              buildNumber: '$(Build.BuildNumber)'
              projectKey: 'prd'
          - task: JfrogCliV2@1
            displayName: Add ownership property to artifacts
            inputs:
              jfrogPlatformConnection: 'JFrog Platform'
              command: |
                jf rt sp "engie.owner=${{ variables.owner }}" --build "$(ProjectName)/$(Build.BuildNumber)"
                jf rt sp "engie.assetPriority=${{ variables.engieAssetPriority }}" --build "$(ProjectName)/$(Build.BuildNumber)"
                jf rt sp "engie.application=$(ProjectName) --build "$(ProjectName)/$(Build.BuildNumber)"
                jf rt sp "engie.assetClassification=${{ variables.engieAssetClassification }}" --build "$(ProjectName)/$(Build.BuildNumber)"



